<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Shooter - Operaciones Combinadas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #0a0a1f, #1a0a2e);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 3px solid #4a90e2;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        }

        canvas {
            display: block;
            background: radial-gradient(ellipse at center, #1a1a3e 0%, #0a0a1f 100%);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #4af;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(74, 170, 255, 0.8);
            z-index: 10;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #8af;
            font-size: 14px;
            text-align: center;
            z-index: 10;
        }

        #inputModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.95);
            border: 3px solid #4af;
            padding: 30px;
            border-radius: 10px;
            display: none;
            z-index: 20;
            box-shadow: 0 0 50px rgba(74, 170, 255, 0.8);
        }

        #inputModal.active {
            display: block;
        }

        #inputModal h2 {
            color: #4af;
            margin-bottom: 15px;
            text-align: center;
        }

        #inputModal input {
            width: 100%;
            padding: 10px;
            font-size: 24px;
            text-align: center;
            background: #1a1a3e;
            border: 2px solid #4af;
            color: #fff;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        #inputModal button {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            background: #4af;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #inputModal button:hover {
            background: #6bf;
            transform: scale(1.05);
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        #difficulty {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }

        #difficulty select {
            padding: 8px;
            background: #1a1a3e;
            color: #4af;
            border: 2px solid #4af;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="hud">
            <div>Puntos: <span id="score">0</span></div>
            <div>Racha: <span id="streak">0</span></div>
            <div>Nivel: <span id="level">1</span></div>
        </div>

        <div id="difficulty">
            <select id="difficultySelect">
                <option value="1">Nivel 1 - Auto</option>
                <option value="2">Nivel 2 - Input</option>
            </select>
        </div>

        <div id="instructions">
            ← → Mover | ESPACIO Disparar
        </div>

        <div id="inputModal">
            <h2 id="questionText">¿Cuánto es 2 × 3?</h2>
            <input type="number" id="answerInput" placeholder="Escribe tu respuesta">
            <button onclick="checkAnswer()">Comprobar</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Estado del juego
        let gameState = {
            score: 0,
            streak: 0,
            difficulty: 1,
            paused: false,
            currentAnswer: null,
            particles: []
        };

        // Jugador
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            width: 30,
            height: 40,
            speed: 5,
            vx: 0
        };

        // Controles
        const keys = {};
        const bullets = [];

        // Sistema de operaciones
        class MathChunk {
            constructor(text, x, y, isOperator = false) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.isOperator = isOperator;
                this.hp = isOperator ? 3 : 999;
                this.maxHp = 3;
                this.isTarget = false;
                this.width = 50;
                this.height = 60;
                this.flashTimer = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
                this.baseY = y;
            }

            update() {
                // Movimiento flotante
                this.y = this.baseY + Math.sin(Date.now() / 1000 + this.floatOffset) * 10;
                
                if (this.flashTimer > 0) {
                    this.flashTimer--;
                }
            }

            draw() {
                ctx.save();
                
                // Color según estado
                let color = '#fff';
                if (this.flashTimer > 0) {
                    color = this.isTarget ? '#ff0' : '#f44';
                }
                
                // Dibujar texto
                ctx.font = 'bold 42px Arial';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Paréntesis y corchetes más grandes
                if ('()[]'.includes(this.text)) {
                    ctx.font = 'bold 56px Arial';
                }
                
                ctx.fillText(this.text, this.x, this.y);
                
                // Barra de vida para operadores
                if (this.isOperator && this.hp > 0) {
                    const barWidth = 40;
                    const barHeight = 5;
                    const barX = this.x - barWidth / 2;
                    const barY = this.y + 25;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
                }
                
                ctx.restore();
            }

            takeDamage() {
                if (!this.isOperator) return false;
                
                this.hp--;
                this.flashTimer = 10;
                
                createParticles(this.x, this.y, '#ff0', 8);
                
                return this.hp <= 0;
            }

            contains(x, y) {
                return Math.abs(x - this.x) < this.width / 2 && 
                       Math.abs(y - this.y) < this.height / 2;
            }
        }

        class OperationManager {
            constructor() {
                this.chunks = [];
                this.currentStepIndex = 0;
                this.steps = [];
                this.generateOperation();
            }

            generateOperation() {
                // Generar operación compleja con paréntesis y corchetes
                const ops = ['+', '-', '*', '/'];
                const nums = () => Math.floor(Math.random() * 12) + 1;
                
                // Tipos de expresión compleja
                const templates = [
                    // [(A op B) op C] op D op E
                    () => {
                        const a = nums(), b = nums(), c = nums(), d = nums(), e = nums();
                        const op1 = ops[Math.floor(Math.random() * ops.length)];
                        const op2 = ops[Math.floor(Math.random() * ops.length)];
                        const op3 = ops[Math.floor(Math.random() * ops.length)];
                        const op4 = ops[Math.floor(Math.random() * ops.length)];
                        return ['[', '(', a, op1, b, ')', op2, c, ']', op3, d, op4, e];
                    },
                    // A op (B op C) op [D op E]
                    () => {
                        const a = nums(), b = nums(), c = nums(), d = nums(), e = nums();
                        const op1 = ops[Math.floor(Math.random() * ops.length)];
                        const op2 = ops[Math.floor(Math.random() * ops.length)];
                        const op3 = ops[Math.floor(Math.random() * ops.length)];
                        const op4 = ops[Math.floor(Math.random() * ops.length)];
                        return [a, op1, '(', b, op2, c, ')', op3, '[', d, op4, e, ']'];
                    },
                    // [(A op B op C) op D] op E
                    () => {
                        const a = nums(), b = nums(), c = nums(), d = nums(), e = nums();
                        const op1 = ops[Math.floor(Math.random() * ops.length)];
                        const op2 = ops[Math.floor(Math.random() * ops.length)];
                        const op3 = ops[Math.floor(Math.random() * ops.length)];
                        const op4 = ops[Math.floor(Math.random() * ops.length)];
                        return ['[', '(', a, op1, b, op2, c, ')', op3, d, ']', op4, e];
                    },
                    // A op [B op (C op D)] op E
                    () => {
                        const a = nums(), b = nums(), c = nums(), d = nums(), e = nums();
                        const op1 = ops[Math.floor(Math.random() * ops.length)];
                        const op2 = ops[Math.floor(Math.random() * ops.length)];
                        const op3 = ops[Math.floor(Math.random() * ops.length)];
                        const op4 = ops[Math.floor(Math.random() * ops.length)];
                        return [a, op1, '[', b, op2, '(', c, op3, d, ')', ']', op4, e];
                    }
                ];
                
                const template = templates[Math.floor(Math.random() * templates.length)];
                const expr = template().map(x => x.toString());
                
                // Resolver la expresión paso a paso
                this.steps = this.resolveExpression(expr);
                this.currentStepIndex = 0;
                this.loadStep();
            }

            resolveExpression(expr) {
                const steps = [];
                let current = [...expr];
                
                while (current.length > 1 || current.some(x => '()[]'.includes(x))) {
                    // 1. Buscar paréntesis más internos
                    let openIdx = -1;
                    for (let i = current.length - 1; i >= 0; i--) {
                        if (current[i] === '(' || current[i] === '[') {
                            openIdx = i;
                            break;
                        }
                    }
                    
                    if (openIdx !== -1) {
                        // Encontrar el cierre correspondiente
                        const openChar = current[openIdx];
                        const closeChar = openChar === '(' ? ')' : ']';
                        let closeIdx = current.indexOf(closeChar, openIdx);
                        
                        // Extraer contenido del paréntesis
                        const inside = current.slice(openIdx + 1, closeIdx);
                        
                        // Resolver dentro del paréntesis
                        if (inside.length === 1) {
                            // Solo un número, eliminar paréntesis
                            current = [...current.slice(0, openIdx), ...inside, ...current.slice(closeIdx + 1)];
                            continue;
                        }
                        
                        // Buscar operador de mayor prioridad dentro
                        const targetInfo = this.findTargetOperator(inside);
                        
                        if (targetInfo) {
                            const globalIdx = openIdx + 1 + targetInfo.idx;
                            steps.push({
                                parts: [...current],
                                targetIdx: globalIdx,
                                operation: this.getOperationString(current, globalIdx),
                                result: targetInfo.result
                            });
                            
                            // Reemplazar operación con resultado
                            const newInside = [...inside];
                            newInside.splice(targetInfo.idx - 1, 3, targetInfo.result.toString());
                            current = [...current.slice(0, openIdx + 1), ...newInside, ...current.slice(closeIdx)];
                        }
                    } else {
                        // No hay paréntesis, resolver operador prioritario
                        const targetInfo = this.findTargetOperator(current);
                        
                        if (!targetInfo) break;
                        
                        steps.push({
                            parts: [...current],
                            targetIdx: targetInfo.idx,
                            operation: this.getOperationString(current, targetInfo.idx),
                            result: targetInfo.result
                        });
                        
                        current.splice(targetInfo.idx - 1, 3, targetInfo.result.toString());
                    }
                }
                
                return steps;
            }

            findTargetOperator(expr) {
                const priority = {'*': 3, '/': 3, '+': 2, '-': 2};
                let maxPriority = -1;
                let targetIdx = -1;
                
                // Buscar de izquierda a derecha el operador de mayor prioridad
                for (let i = 0; i < expr.length; i++) {
                    if (priority[expr[i]] !== undefined) {
                        if (priority[expr[i]] > maxPriority) {
                            maxPriority = priority[expr[i]];
                            targetIdx = i;
                        }
                    }
                }
                
                if (targetIdx === -1) return null;
                
                const left = parseFloat(expr[targetIdx - 1]);
                const right = parseFloat(expr[targetIdx + 1]);
                const op = expr[targetIdx];
                
                return {
                    idx: targetIdx,
                    result: this.calculate(left, op, right)
                };
            }

            getOperationString(expr, opIdx) {
                const left = expr[opIdx - 1];
                const op = expr[opIdx];
                const right = expr[opIdx + 1];
                return `${left} ${op} ${right}`;
            }

            calculate(a, op, b) {
                switch(op) {
                    case '+': return a + b;
                    case '-': return a - b;
                    case '*': return a * b;
                    case '/': return Math.round(a / b);
                }
            }

            loadStep() {
                this.chunks = [];
                
                if (this.currentStepIndex >= this.steps.length) {
                    // Nivel completado
                    gameState.score += 500;
                    setTimeout(() => this.generateOperation(), 1000);
                    return;
                }

                const step = this.steps[this.currentStepIndex];
                
                // Calcular espaciado dinámico según longitud
                const totalWidth = canvas.width - 100;
                const spacing = Math.min(70, totalWidth / step.parts.length);
                const startX = (canvas.width - (step.parts.length - 1) * spacing) / 2;
                const y = 200;

                step.parts.forEach((text, i) => {
                    const isOp = '+-*/'.includes(text);
                    const chunk = new MathChunk(text, startX + i * spacing, y, isOp);
                    
                    if (i === step.targetIdx) {
                        chunk.isTarget = true;
                    }
                    
                    this.chunks.push(chunk);
                });
            }

            handleHit(chunk) {
                if (chunk.isTarget) {
                    const destroyed = chunk.takeDamage();
                    
                    if (destroyed) {
                        // Operación resuelta
                        if (gameState.difficulty === 2) {
                            // Modo con input
                            const step = this.steps[this.currentStepIndex];
                            gameState.currentAnswer = step.result;
                            showInputModal(step.operation);
                        } else {
                            // Modo automático
                            this.solveStep();
                        }
                        return 'SOLVED';
                    }
                    return 'HIT';
                } else {
                    // Error
                    chunk.flashTimer = 15;
                    
                    // Iluminar el correcto
                    this.chunks.forEach(c => {
                        if (c.isTarget) c.flashTimer = 30;
                    });
                    
                    return 'WRONG';
                }
            }

            solveStep() {
                gameState.score += 100;
                gameState.streak++;
                this.currentStepIndex++;
                this.loadStep();
            }

            update() {
                this.chunks.forEach(chunk => chunk.update());
            }

            draw() {
                this.chunks.forEach(chunk => chunk.draw());
            }
        }

        let operationManager = new OperationManager();

        // Partículas
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30,
                    color: color
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                return p.life > 0;
            });
        }

        function drawParticles() {
            gameState.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x, p.y, 3, 3);
                ctx.globalAlpha = 1;
            });
        }

        // Estrellas de fondo
        function createStars() {
            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = Math.random() * 2 + 'px';
                star.style.height = star.style.width;
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 2 + 's';
                document.getElementById('gameContainer').appendChild(star);
            }
        }

        // Dibujar nave
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Cuerpo de la nave
            ctx.fillStyle = '#4af';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, 20);
            ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.fill();
            
            // Motor
            ctx.fillStyle = '#f80';
            ctx.fillRect(-5, 20, 10, 8);
            
            // Llama del motor
            if (keys['ArrowLeft'] || keys['ArrowRight']) {
                ctx.fillStyle = '#ff0';
                ctx.fillRect(-3, 28, 6, 5);
            }
            
            ctx.restore();
        }

        // Sistema de balas
        function shoot() {
            bullets.push({
                x: player.x,
                y: player.y - 25,
                width: 4,
                height: 15,
                speed: 8
            });
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                
                // Eliminar si sale de pantalla
                if (bullets[i].y < 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Colisión con chunks
                for (let chunk of operationManager.chunks) {
                    if (chunk.contains(bullets[i].x, bullets[i].y)) {
                        const result = operationManager.handleHit(chunk);
                        
                        if (result === 'HIT') {
                            gameState.score += 10;
                        } else if (result === 'SOLVED') {
                            gameState.score += 50;
                        } else if (result === 'WRONG') {
                            gameState.streak = 0;
                            gameState.score = Math.max(0, gameState.score - 5);
                        }
                        
                        bullets.splice(i, 1);
                        updateHUD();
                        break;
                    }
                }
            }
        }

        function drawBullets() {
            ctx.fillStyle = '#0ff';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                
                // Efecto de brillo
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fillRect(bullet.x - bullet.width/2 - 2, bullet.y, bullet.width + 4, bullet.height);
                ctx.fillStyle = '#0ff';
            });
        }

        // Modal de input
        function showInputModal(operation) {
            gameState.paused = true;
            document.getElementById('questionText').textContent = `¿Cuánto es ${operation.replace('*', '×').replace('/', '÷')}?`;
            document.getElementById('inputModal').classList.add('active');
            document.getElementById('answerInput').value = '';
            document.getElementById('answerInput').focus();
        }

        function checkAnswer() {
            const input = parseInt(document.getElementById('answerInput').value);
            
            if (input === gameState.currentAnswer) {
                // Respuesta correcta
                gameState.score += 200;
                gameState.streak++;
                operationManager.solveStep();
                hideInputModal();
            } else {
                // Respuesta incorrecta
                gameState.score = Math.max(0, gameState.score - 50);
                gameState.streak = 0;
                document.getElementById('answerInput').style.borderColor = '#f44';
                setTimeout(() => {
                    document.getElementById('answerInput').style.borderColor = '#4af';
                }, 500);
            }
            
            updateHUD();
        }

        function hideInputModal() {
            document.getElementById('inputModal').classList.remove('active');
            gameState.paused = false;
        }

        // HUD
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('level').textContent = gameState.difficulty;
        }

        // Eventos
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ' && !gameState.paused) {
                e.preventDefault();
                shoot();
            }
            
            if (e.key === 'Enter' && gameState.paused) {
                checkAnswer();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.getElementById('difficultySelect').addEventListener('change', (e) => {
            gameState.difficulty = parseInt(e.target.value);
            updateHUD();
        });

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.paused) {
                // Mover jugador
                if (keys['ArrowLeft']) player.x = Math.max(30, player.x - player.speed);
                if (keys['ArrowRight']) player.x = Math.min(canvas.width - 30, player.x + player.speed);
                
                updateBullets();
                operationManager.update();
                updateParticles();
            }
            
            // Dibujar
            operationManager.draw();
            drawBullets();
            drawParticles();
            drawPlayer();
            
            requestAnimationFrame(gameLoop);
        }

        // Iniciar
        createStars();
        updateHUD();
        gameLoop();
    </script>
</body>
</html>
