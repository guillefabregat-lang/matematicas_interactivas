<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Domin√≥ de Potencias - Matem√°ticas Interactivas</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none; /* Evitar selecci√≥n de texto al arrastrar */
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to bottom right, #f0f9ff, #e0f2fe, #fae8ff);
      color: #1e293b;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      text-align: center;
    }

    header { margin-bottom: 20px; }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #0ea5e9, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle { font-size: 1.2rem; color: #475569; margin-bottom: 20px; }

    .game-info {
      display: flex;
      justify-content: space-around;
      margin-bottom: 20px;
      background: rgba(255, 255, 255, 0.7);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }

    .info-item { display: flex; flex-direction: column; align-items: center; }
    .info-value { font-size: 1.8rem; font-weight: bold; color: #0ea5e9; }
    .info-label { font-size: 0.9rem; color: #64748b; }

    .game-area {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      height: 600px; /* Altura fija para el √°rea de juego */
    }

    @media (max-width: 768px) {
      .game-area { flex-direction: column; height: auto; }
      #tablero { min-height: 400px; }
    }

    #mano {
      width: 280px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      overflow-y: auto;
    }

    #tablero {
      flex: 1;
      background: rgba(255, 255, 255, 0.5);
      border: 2px dashed #cbd5e1;
      border-radius: 15px;
      position: relative;
      overflow: hidden; /* Importante para que no salgan scrollbars infinitos */
    }

    /* Contenedor l√≥gico de la ficha */
    .ficha-container {
      position: absolute;
      width: 140px;
      height: 70px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      /* Transiciones suaves solo para transform, no para left/top durante arrastre */
      transition: transform 0.2s, box-shadow 0.2s; 
    }

    /* La parte visual de la ficha */
    .ficha {
      width: 140px;
      height: 70px;
      background: white;
      border: 3px solid #0ea5e9;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      cursor: grab;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      /* La rotaci√≥n se aplica aqu√≠ */
      transform-origin: center center;
      transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    .ficha:active { cursor: grabbing; }

    .ficha:hover {
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      z-index: 100;
    }

    .lado {
      width: 45%;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      color: #1e293b;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
      border-radius: 5px;
      background: rgba(14, 165, 233, 0.05);
    }
    
    /* Manejo visual de la rotaci√≥n del texto interno para que siempre se lea bien */
    .ficha[data-rotacion="90"] .lado, .ficha[data-rotacion="-270"] .lado { transform: rotate(-90deg); }
    .ficha[data-rotacion="180"] .lado, .ficha[data-rotacion="-180"] .lado { transform: rotate(-180deg); }
    .ficha[data-rotacion="270"] .lado, .ficha[data-rotacion="-90"] .lado { transform: rotate(-270deg); }

    .lado.match {
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      animation: pulse 1s infinite alternate;
    }

    @keyframes pulse {
      from { box-shadow: 0 0 5px rgba(16, 185, 129, 0.5); }
      to { box-shadow: 0 0 15px rgba(16, 185, 129, 0.8); }
    }

    .separador {
      width: 3px;
      height: 80%;
      background: #0ea5e9;
      border-radius: 2px;
    }

    /* Botones de rotaci√≥n posicionados fuera del √°rea de colisi√≥n */
    .botones {
      position: absolute;
      bottom: -40px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 10px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none; /* Inactivos hasta que se vean */
    }

    .ficha-container:hover .botones,
    .botones:hover {
      opacity: 1;
      pointer-events: all;
    }

    .botones button {
      padding: 5px 10px;
      font-size: 12px;
      background: #8b5cf6;
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .botones button:hover { background: #7c3aed; transform: scale(1.1); }

    .controls { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }

    button.control-btn {
      padding: 12px 24px;
      font-size: 1rem;
      background: #0ea5e9;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    button.control-btn:hover { background: #0284c7; transform: translateY(-2px); }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      color: #1e293b;
      padding: 30px 50px;
      border-radius: 15px;
      font-size: 1.5rem;
      z-index: 2000;
      display: none;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
      border: 3px solid #0ea5e9;
      text-align: center;
    }

    .conexion {
      position: absolute;
      height: 4px;
      background: #10b981;
      z-index: 5;
      transform-origin: 0 50%;
      border-radius: 2px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üé≤ Domin√≥ de Potencias</h1>
      <p class="subtitle">Arrastra, conecta y evita superponer las piezas</p>
    </header>

    <div class="game-info">
      <div class="info-item">
        <div class="info-value" id="puntuacion">0</div>
        <div class="info-label">Puntos</div>
      </div>
      <div class="info-item">
        <div class="info-value" id="conexiones">0</div>
        <div class="info-label">Conexiones</div>
      </div>
      <div class="info-item">
        <div class="info-value" id="tiempo">180</div>
        <div class="info-label">Segundos</div>
      </div>
    </div>

    <div class="game-area">
      <div id="mano">
        <h3 style="margin-bottom: 10px;">Tu Mano</h3>
      </div>
      <div id="tablero"></div>
    </div>

    <div class="controls">
      <button class="control-btn" id="btn-nueva-partida">üéÆ Nueva Partida</button>
      <button class="control-btn" id="btn-pista">üí° Pista</button>
    </div>
  </div>

  <div class="message" id="message"></div>

  <script>
    // --- CONFIGURACI√ìN ---
    const config = {
      tiempoTotal: 180,
      puntosPorConexion: 15,
      distanciaEnganche: 50, // P√≠xeles de cercan√≠a para activar el im√°n
    };

    // --- ESTADO ---
    let estado = {
      puntuacion: 0,
      conexiones: 0,
      tiempoRestante: config.tiempoTotal,
      temporizador: null,
      fichasEnTablero: [], // Array de objetos {id, container, elemento, valorA, valorB}
      gruposConectados: []
    };

    // --- DATOS MATEM√ÅTICOS ---
    const expresiones = [
      { expr: "2¬≤", valor: 4 }, { expr: "4", valor: 4 },
      { expr: "2¬≥", valor: 8 }, { expr: "8", valor: 8 },
      { expr: "2‚Å¥", valor: 16 }, { expr: "16", valor: 16 }, { expr: "4¬≤", valor: 16 },
      { expr: "2‚Åµ", valor: 32 }, { expr: "32", valor: 32 },
      { expr: "3¬≤", valor: 9 }, { expr: "9", valor: 9 }, { expr: "3√ó3", valor: 9 },
      { expr: "3¬≥", valor: 27 }, { expr: "27", valor: 27 },
      { expr: "5¬≤", valor: 25 }, { expr: "25", valor: 25 },
      { expr: "5¬≥", valor: 125 }, { expr: "125", valor: 125 },
      { expr: "10¬≤", valor: 100 }, { expr: "100", valor: 100 },
      { expr: "6¬≤", valor: 36 }, { expr: "36", valor: 36 },
      { expr: "‚àö16", valor: 4 }, { expr: "‚àö64", valor: 8 }, { expr: "‚àö81", valor: 9 }
    ];

    const tablero = document.getElementById('tablero');
    const mano = document.getElementById('mano');

    // --- GENERACI√ìN DE FICHAS ---
    function generarFichas() {
      const fichas = [];
      const expUsadas = new Set();
      
      for (let i = 0; i < 10; i++) {
        let exp1, exp2;
        // Evitar dobles triviales y repetidos exactos
        let intentos = 0;
        do {
          exp1 = expresiones[Math.floor(Math.random() * expresiones.length)];
          exp2 = expresiones[Math.floor(Math.random() * expresiones.length)];
          intentos++;
        } while ((exp1.valor === exp2.valor || expUsadas.has(exp1.expr + exp2.expr)) && intentos < 50);
        
        expUsadas.add(exp1.expr + exp2.expr);
        
        fichas.push({
          id: i + 1,
          ladoA: { expr: exp1.expr, valor: exp1.valor },
          ladoB: { expr: exp2.expr, valor: exp2.valor },
          rotacion: 0
        });
      }
      return fichas;
    }

    function crearFicha(f) {
      const container = document.createElement("div");
      container.className = "ficha-container";
      container.dataset.id = f.id;
      // Posici√≥n relativa inicial en la mano
      container.style.position = "relative"; 
      
      const div = document.createElement("div");
      div.className = "ficha";
      div.dataset.valorA = f.ladoA.valor;
      div.dataset.valorB = f.ladoB.valor;
      div.dataset.rotacion = f.rotacion || 0;

      div.innerHTML = `
        <div class="lado lado-a">${f.ladoA.expr}</div>
        <div class="separador"></div>
        <div class="lado lado-b">${f.ladoB.expr}</div>
      `;
      
      const botones = document.createElement("div");
      botones.className = "botones";
      botones.innerHTML = `
        <button onmousedown="event.stopPropagation()" onclick="rotarFicha(${f.id}, -90)">‚Ü∫</button>
        <button onmousedown="event.stopPropagation()" onclick="rotarFicha(${f.id}, 90)">‚Üª</button>
      `;
      
      container.appendChild(div);
      container.appendChild(botones);

      activarArrastre(container, div);
      return container;
    }

    // --- L√ìGICA DE ARRASTRE Y COLISIONES (CORE) ---

    function activarArrastre(container, fichaElem) {
      let offsetX, offsetY;
      let startX, startY; // Para revertir movimiento
      let grupoArrastrado = [];
      let isDragging = false;

      container.addEventListener('mousedown', iniciarArrastre);

      function iniciarArrastre(e) {
        if (e.target.tagName === 'BUTTON') return;
        e.preventDefault();

        // 1. Si est√° en la mano, pasar al tablero
        if (container.parentElement === mano) {
          const rectMano = container.getBoundingClientRect();
          const rectTab = tablero.getBoundingClientRect();
          
          tablero.appendChild(container);
          container.style.position = 'absolute';
          // Calcular posici√≥n relativa al tablero donde estaba en la pantalla
          const relativeLeft = rectMano.left - rectTab.left;
          const relativeTop = rectMano.top - rectTab.top;
          
          container.style.left = relativeLeft + 'px';
          container.style.top = relativeTop + 'px';
        }

        // 2. Preparar arrastre
        const rect = container.getBoundingClientRect();
        const tableroRect = tablero.getBoundingClientRect();

        // Guardar posici√≥n inicial por si el movimiento es inv√°lido
        startX = parseFloat(container.style.left);
        startY = parseFloat(container.style.top);
        
        // Offset del rat√≥n respecto a la esquina de la ficha
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        // Identificar si esta ficha es parte de un grupo conectado
        grupoArrastrado = obtenerGrupoConectado(parseInt(container.dataset.id));
        
        // Preparar visualmente todo el grupo
        grupoArrastrado.forEach(f => {
          f.container.style.zIndex = "1000";
          f.container.style.cursor = "grabbing";
          // Desactivar transici√≥n para que el arrastre sea instant√°neo y fluido
          f.container.style.transition = "none";
          
          const fRect = f.container.getBoundingClientRect();
          // Offset relativo de cada ficha del grupo respecto a la ficha principal
          f.deltaX = fRect.left - rect.left;
          f.deltaY = fRect.top - rect.top;
        });

        isDragging = true;
        document.addEventListener('mousemove', arrastrar);
        document.addEventListener('mouseup', soltarFicha);
      }

      function arrastrar(e) {
        if (!isDragging) return;
        e.preventDefault();
        
        const tableroRect = tablero.getBoundingClientRect();
        const mouseX = e.clientX - tableroRect.left;
        const mouseY = e.clientY - tableroRect.top;

        // Mover todo el grupo
        grupoArrastrado.forEach(f => {
          let x = mouseX - offsetX + f.deltaX;
          let y = mouseY - offsetY + f.deltaY;
          f.container.style.left = x + "px";
          f.container.style.top = y + "px";
        });
      }

      function soltarFicha(e) {
        isDragging = false;
        document.removeEventListener('mousemove', arrastrar);
        document.removeEventListener('mouseup', soltarFicha);

        // 1. Intentar ENGANCHE MAGN√âTICO (Snap)
        const fichaPrincipal = grupoArrastrado.find(f => f.container === container);
        const seEngancho = intentarEnganche(fichaPrincipal, grupoArrastrado);

        // 2. Verificar COLISIONES (Superposici√≥n)
        let hayColision = false;
        grupoArrastrado.forEach(f => {
          if (verificarColisionConOtras(f, grupoArrastrado)) hayColision = true;
          
          // Verificar l√≠mites del tablero
          const r = f.container.getBoundingClientRect();
          const t = tablero.getBoundingClientRect();
          if (r.left < t.left || r.top < t.top || r.right > t.right || r.bottom > t.bottom) {
             hayColision = true; // Salio del tablero
          }
        });

        if (hayColision) {
          // REVERTIR MOVIMIENTO
          grupoArrastrado.forEach(f => {
            if (f.container === container) {
              f.container.style.left = startX + "px";
              f.container.style.top = startY + "px";
            } else {
              // Recalcular posici√≥n original basada en la ficha principal
              // Esto simplifica asumiendo que el grupo mantiene estructura r√≠gida
              // (En una implementaci√≥n perfecta guardar√≠amos startX/Y de cada uno)
              f.container.style.left = (startX + f.deltaX) + "px";
              f.container.style.top = (startY + f.deltaY) + "px";
            }
          });
          
          if(!seEngancho) mostrarMensaje("‚ùå Lugar ocupado", false);
        } else {
          // MOVIMIENTO V√ÅLIDO
          // Registrar fichas en el estado global si son nuevas en el tablero
          const fichaId = parseInt(container.dataset.id);
          if (!estado.fichasEnTablero.find(f => f.id === fichaId)) {
            estado.fichasEnTablero.push({
              id: fichaId,
              container: container,
              elemento: fichaElem,
              valorA: parseInt(fichaElem.dataset.valorA),
              valorB: parseInt(fichaElem.dataset.valorB)
            });
          }
        }

        // Restaurar estilos y verificar puntos
        grupoArrastrado.forEach(f => {
          f.container.style.zIndex = "10";
          f.container.style.cursor = "grab";
          f.container.style.transition = "transform 0.2s, box-shadow 0.2s";
        });
        
        verificarConexiones();
      }
    }

    // --- FUNCIONES DE GEOMETR√çA Y F√çSICA ---

    function verificarColisionConOtras(fichaData, grupoIgnorar) {
      const margen = 2; // Peque√±o margen de tolerancia
      const rect1 = fichaData.container.getBoundingClientRect();
      const idsIgnorar = grupoIgnorar.map(g => g.id);

      // Reducir rect colisi√≥n un poco (hitbox m√°s peque√±o que visual)
      const r1 = {
        left: rect1.left + margen, right: rect1.right - margen,
        top: rect1.top + margen, bottom: rect1.bottom - margen
      };

      for (let otra of estado.fichasEnTablero) {
        if (idsIgnorar.includes(otra.id)) continue; // No chocar consigo misma ni su grupo

        const rect2 = otra.container.getBoundingClientRect();
        const r2 = {
          left: rect2.left + margen, right: rect2.right - margen,
          top: rect2.top + margen, bottom: rect2.bottom - margen
        };

        // Detecci√≥n AABB (Axis-Aligned Bounding Box)
        const superponen = !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
        if (superponen) return true;
      }
      return false;
    }

    function intentarEnganche(fichaData, grupo) {
      const idMov = fichaData.id;
      const rectMov = fichaData.container.getBoundingClientRect();
      const rotMov = parseInt(fichaData.elemento.dataset.rotacion) || 0;
      
      let mejorDistancia = config.distanciaEnganche;
      let ajuste = null;

      const ladosMov = getLadosCentros(rectMov, rotMov);

      // Buscar posibles conexiones con fichas fijas
      estado.fichasEnTablero.forEach(fija => {
        // Ignorar si es del mismo grupo
        if (grupo.find(g => g.id === fija.id)) return;

        const rectFija = fija.container.getBoundingClientRect();
        const rotFija = parseInt(fija.elemento.dataset.rotacion) || 0;
        const ladosFija = getLadosCentros(rectFija, rotFija);

        const combinaciones = [
          { pMov: ladosMov.izq, valMov: fichaData.valorA, pFija: ladosFija.izq, valFija: fija.valorA },
          { pMov: ladosMov.izq, valMov: fichaData.valorA, pFija: ladosFija.der, valFija: fija.valorB },
          { pMov: ladosMov.der, valMov: fichaData.valorB, pFija: ladosFija.izq, valFija: fija.valorA },
          { pMov: ladosMov.der, valMov: fichaData.valorB, pFija: ladosFija.der, valFija: fija.valorB }
        ];

        combinaciones.forEach(combo => {
          if (combo.valMov === combo.valFija) {
            const dist = Math.hypot(combo.pMov.x - combo.pFija.x, combo.pMov.y - combo.pFija.y);
            
            if (dist < mejorDistancia) {
              mejorDistancia = dist;
              // Calculamos el vector exacto para mover pMov sobre pFija
              ajuste = { 
                dx: combo.pFija.x - combo.pMov.x,
                dy: combo.pFija.y - combo.pMov.y 
              };
            }
          }
        });
      });

      if (ajuste) {
        // Aplicar ajuste a todo el grupo
        grupo.forEach(f => {
          const curLeft = parseFloat(f.container.style.left);
          const curTop = parseFloat(f.container.style.top);
          f.container.style.left = (curLeft + ajuste.dx) + "px";
          f.container.style.top = (curTop + ajuste.dy) + "px";
        });
        return true;
      }
      return false;
    }

    // Calcula el centro geom√©trico de los lados izquierdo y derecho visuales
    function getLadosCentros(rect, rot) {
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      
      // Vector del centro al lado derecho (sin rotaci√≥n) -> (70, 0) porque ancho es 140
      // Vector del centro al lado izquierdo -> (-70, 0)
      const radio = 70; 
      
      // Convertir a radianes
      const rad = (rot * Math.PI) / 180;
      
      // Rotar el vector (radio, 0)
      const dx = Math.cos(rad) * radio;
      const dy = Math.sin(rad) * radio;

      return {
        der: { x: cx + dx, y: cy + dy },
        izq: { x: cx - dx, y: cy - dy }
      };
    }

    function obtenerGrupoConectado(fichaId) {
      // B√∫squeda en anchura (BFS) para encontrar todas las fichas conectadas
      const raiz = estado.fichasEnTablero.find(f => f.id === fichaId);
      if (!raiz) return [{ // Si a√∫n no est√° en tablero (reci√©n salida de mano), es grupo de 1
         container: document.querySelector(`.ficha-container[data-id="${fichaId}"]`),
         id: fichaId
      }];

      const grupo = [raiz];
      const visitados = new Set([fichaId]);
      const cola = [raiz];

      while (cola.length > 0) {
        const actual = cola.shift();
        
        // Buscar vecinos conectados
        estado.fichasEnTablero.forEach(otra => {
          if (!visitados.has(otra.id) && estanConectadasFisicamente(actual, otra)) {
            visitados.add(otra.id);
            grupo.push(otra);
            cola.push(otra);
          }
        });
      }
      return grupo;
    }

    function estanConectadasFisicamente(f1, f2) {
      // Verifica si dos fichas est√°n lo suficientemente cerca y alineadas
      const r1 = f1.container.getBoundingClientRect();
      const r2 = f2.container.getBoundingClientRect();
      const rot1 = parseInt(f1.elemento.dataset.rotacion) || 0;
      const rot2 = parseInt(f2.elemento.dataset.rotacion) || 0;
      
      const pts1 = getLadosCentros(r1, rot1);
      const pts2 = getLadosCentros(r2, rot2);
      
      const threshold = 5; // Tolerancia muy baja porque el im√°n las pone exactas
      
      // Revisar cruces
      const cruces = [
         {d: Math.hypot(pts1.izq.x - pts2.izq.x, pts1.izq.y - pts2.izq.y), match: f1.valorA === f2.valorA},
         {d: Math.hypot(pts1.izq.x - pts2.der.x, pts1.izq.y - pts2.der.y), match: f1.valorA === f2.valorB},
         {d: Math.hypot(pts1.der.x - pts2.izq.x, pts1.der.y - pts2.izq.y), match: f1.valorB === f2.valorA},
         {d: Math.hypot(pts1.der.x - pts2.der.x, pts1.der.y - pts2.der.y), match: f1.valorB === f2.valorB}
      ];
      
      return cruces.some(c => c.d < threshold && c.match);
    }

    // --- ROTACI√ìN ---
    function rotarFicha(fichaId, grados) {
      const container = document.querySelector(`.ficha-container[data-id="${fichaId}"]`);
      if (!container) return;
      const ficha = container.querySelector('.ficha');

      let rotActual = parseInt(ficha.dataset.rotacion) || 0;
      rotActual += grados;
      
      // Normalizar angulo
      while (rotActual > 180) rotActual -= 360;
      while (rotActual < -180) rotActual += 360;

      ficha.dataset.rotacion = rotActual;
      ficha.style.transform = `rotate(${rotActual}deg)`;

      // Esperar a que acabe transici√≥n visual para verificar
      setTimeout(() => {
        verificarConexiones();
      }, 300);
    }

    // --- PUNTUACI√ìN Y UI ---
    function verificarConexiones() {
      // Limpiar l√≠neas anteriores
      document.querySelectorAll('.conexion').forEach(c => c.remove());
      document.querySelectorAll('.lado.match').forEach(l => l.classList.remove('match'));

      let conexionesTotal = 0;
      const visitados = new Set();

      estado.fichasEnTablero.forEach(f1 => {
        estado.fichasEnTablero.forEach(f2 => {
          if (f1.id >= f2.id) return; // Evitar duplicados

          if (estanConectadasFisicamente(f1, f2)) {
             dibujarLineaEntreFichas(f1, f2);
             conexionesTotal++;
          }
        });
      });

      // Actualizar estado solo si cambia
      if (conexionesTotal !== estado.conexiones) {
        estado.conexiones = conexionesTotal;
        estado.puntuacion = conexionesTotal * config.puntosPorConexion;
        actualizarUI();
        
        if (conexionesTotal >= 9 && estado.fichasEnTablero.length === 10) {
          mostrarMensaje("üéâ ¬°Juego Completado!", true);
          clearInterval(estado.temporizador);
        }
      }
    }

    function dibujarLineaEntreFichas(f1, f2) {
       const r1 = f1.container.getBoundingClientRect();
       const r2 = f2.container.getBoundingClientRect();
       const rot1 = parseInt(f1.elemento.dataset.rotacion) || 0;
       const rot2 = parseInt(f2.elemento.dataset.rotacion) || 0;
       const p1 = getLadosCentros(r1, rot1);
       const p2 = getLadosCentros(r2, rot2);
       
       // Encontrar qu√© puntos est√°n cerca
       let start, end;
       if (Math.hypot(p1.izq.x - p2.izq.x, p1.izq.y - p2.izq.y) < 10) { start = p1.izq; end = p2.izq; marcar(f1, 'a'); marcar(f2, 'a'); }
       else if (Math.hypot(p1.izq.x - p2.der.x, p1.izq.y - p2.der.y) < 10) { start = p1.izq; end = p2.der; marcar(f1, 'a'); marcar(f2, 'b'); }
       else if (Math.hypot(p1.der.x - p2.izq.x, p1.der.y - p2.izq.y) < 10) { start = p1.der; end = p2.izq; marcar(f1, 'b'); marcar(f2, 'a'); }
       else if (Math.hypot(p1.der.x - p2.der.x, p1.der.y - p2.der.y) < 10) { start = p1.der; end = p2.der; marcar(f1, 'b'); marcar(f2, 'b'); }

       if (start && end) {
         const tRect = tablero.getBoundingClientRect();
         const linea = document.createElement('div');
         linea.className = 'conexion';
         linea.style.width = '20px'; // Linea corta visual
         linea.style.left = (start.x - tRect.left - 10) + 'px';
         linea.style.top = (start.y - tRect.top - 2) + 'px';
         tablero.appendChild(linea);
       }
    }

    function marcar(ficha, lado) {
      ficha.elemento.querySelector(`.lado-${lado}`).classList.add('match');
    }

    // --- GESTI√ìN DEL JUEGO ---
    function iniciarJuego() {
      clearInterval(estado.temporizador);
      estado = {
        puntuacion: 0,
        conexiones: 0,
        tiempoRestante: config.tiempoTotal,
        temporizador: null,
        fichasEnTablero: [],
        gruposConectados: []
      };

      tablero.innerHTML = '';
      mano.innerHTML = '<h3 style="margin-bottom: 10px;">Tu Mano</h3>';

      const fichas = generarFichas();
      fichas.forEach(f => {
        const elem = crearFicha(f);
        mano.appendChild(elem);
      });

      actualizarUI();
      estado.temporizador = setInterval(() => {
        estado.tiempoRestante--;
        document.getElementById('tiempo').textContent = estado.tiempoRestante;
        if (estado.tiempoRestante <= 0) {
          clearInterval(estado.temporizador);
          mostrarMensaje(`‚è∞ Tiempo agotado. Pts: ${estado.puntuacion}`);
        }
      }, 1000);
    }

    function actualizarUI() {
      document.getElementById('puntuacion').textContent = estado.puntuacion;
      document.getElementById('conexiones').textContent = estado.conexiones;
      document.getElementById('tiempo').textContent = estado.tiempoRestante;
    }

    function mostrarMensaje(texto, esVictoria = false) {
      const msg = document.getElementById('message');
      msg.textContent = texto;
      msg.style.display = 'block';
      msg.style.borderColor = esVictoria ? '#10b981' : '#ef4444';
      setTimeout(() => { msg.style.display = 'none'; }, 2000);
    }

    document.getElementById('btn-nueva-partida').onclick = iniciarJuego;
    document.getElementById('btn-pista').onclick = () => mostrarMensaje("üí° Une lados con el mismo valor (ej: 2¬≤ con 4)");

    window.onload = iniciarJuego;
  </script>
</body>
</html>
