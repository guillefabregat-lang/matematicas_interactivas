<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Domin√≥ de Potencias - Matem√°ticas Interactivas</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to bottom right, #f0f9ff, #e0f2fe, #fae8ff);
      color: #1e293b;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      text-align: center;
    }

    header {
      margin-bottom: 20px;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #0ea5e9, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #475569;
    }

    .game-info {
      display: flex;
      justify-content: space-around;
      margin-bottom: 20px;
      background: rgba(255, 255, 255, 0.7);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }

    .info-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .info-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #0ea5e9;
    }

    .info-label {
      font-size: 0.9rem;
      color: #64748b;
    }

    .game-area {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 768px) {
      .game-area {
        flex-direction: column;
      }
    }

    #mano {
      width: 280px;
      min-height: 500px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    #tablero {
      flex: 1;
      min-height: 500px;
      background: rgba(255, 255, 255, 0.5);
      border: 2px dashed #cbd5e1;
      border-radius: 15px;
      position: relative;
      overflow: visible;
    }

    .ficha {
      width: 140px;
      height: 70px;
      background: white;
      border: 3px solid #0ea5e9;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      cursor: move;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      z-index: 10;
    }
    
    .ficha-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .ficha:hover {
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      transform: scale(1.05);
    }

    .lado {
      width: 45%;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      color: #1e293b;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
      border-radius: 5px;
      background: rgba(14, 165, 233, 0.05);
      transform: rotate(0deg);
      transition: none;
    }
    
    .ficha[data-rotacion="90"] .lado,
    .ficha[data-rotacion="-270"] .lado {
      transform: rotate(-90deg);
    }
    
    .ficha[data-rotacion="180"] .lado,
    .ficha[data-rotacion="-180"] .lado {
      transform: rotate(-180deg);
    }
    
    .ficha[data-rotacion="270"] .lado,
    .ficha[data-rotacion="-90"] .lado {
      transform: rotate(-270deg);
    }

    .lado.match {
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      animation: pulse 1s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .separador {
      width: 3px;
      height: 80%;
      background: #0ea5e9;
      border-radius: 2px;
    }

    .botones {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 1001;
    }

    .ficha-container:hover .botones,
    .botones:hover {
      opacity: 1;
      pointer-events: all;
    }

    .botones button {
      padding: 6px 12px;
      font-size: 14px;
      background: #8b5cf6;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .botones button:hover {
      background: #7c3aed;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 12px 24px;
      font-size: 1rem;
      background: #0ea5e9;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    button:hover {
      background: #0284c7;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      color: #1e293b;
      padding: 30px 50px;
      border-radius: 15px;
      font-size: 1.5rem;
      z-index: 1000;
      display: none;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      border: 3px solid #0ea5e9;
    }

    .conexion {
      position: absolute;
      height: 5px;
      background: linear-gradient(90deg, #10b981, #34d399);
      z-index: 5;
      transform-origin: 0 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.5);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üé≤ Domin√≥ de Potencias</h1>
      <p class="subtitle">Conecta los lados con valores equivalentes</p>
    </header>

    <div class="game-info">
      <div class="info-item">
        <div class="info-value" id="puntuacion">0</div>
        <div class="info-label">Puntos</div>
      </div>
      <div class="info-item">
        <div class="info-value" id="conexiones">0</div>
        <div class="info-label">Conexiones</div>
      </div>
      <div class="info-item">
        <div class="info-value" id="tiempo">180</div>
        <div class="info-label">Segundos</div>
      </div>
    </div>

    <div class="game-area">
      <div id="mano">
        <h3 style="margin-bottom: 10px;">Tu Mano</h3>
        <p style="font-size: 0.9rem; color: #64748b;">Arrastra al tablero ‚Üí</p>
      </div>
      <div id="tablero"></div>
    </div>

    <div class="controls">
      <button id="btn-nueva-partida">üéÆ Nueva Partida</button>
      <button id="btn-voltear-todas">üîÑ Voltear Todas</button>
      <button id="btn-pista">üí° Pista</button>
    </div>
  </div>

  <div class="message" id="message"></div>

  <script>
    // Configuraci√≥n
    const config = {
      tiempoTotal: 180,
      puntosPorConexion: 15,
      distanciaConexion: 80,
      distanciaEnganche: 100, // Distancia para activar enganche magn√©tico
      fuerzaEnganche: 15 // P√≠xeles de ajuste para enganche
    };

    // Estado del juego
    let estado = {
      puntuacion: 0,
      conexiones: 0,
      tiempoRestante: config.tiempoTotal,
      temporizador: null,
      fichasEnTablero: [],
      lineasConexion: [],
      gruposConectados: [] // Grupos de fichas que se mueven juntas
    };

    // Banco de expresiones con sus valores
    const expresiones = [
      { expr: "2¬≤", valor: 4 },
      { expr: "4", valor: 4 },
      { expr: "2¬≥", valor: 8 },
      { expr: "8", valor: 8 },
      { expr: "2‚Å¥", valor: 16 },
      { expr: "16", valor: 16 },
      { expr: "4¬≤", valor: 16 },
      { expr: "2‚Åµ", valor: 32 },
      { expr: "32", valor: 32 },
      { expr: "3¬≤", valor: 9 },
      { expr: "9", valor: 9 },
      { expr: "3¬≥", valor: 27 },
      { expr: "27", valor: 27 },
      { expr: "5¬≤", valor: 25 },
      { expr: "25", valor: 25 },
      { expr: "5¬≥", valor: 125 },
      { expr: "125", valor: 125 },
      { expr: "10¬≤", valor: 100 },
      { expr: "100", valor: 100 },
      { expr: "6¬≤", valor: 36 },
      { expr: "36", valor: 36 },
      { expr: "‚àö16", valor: 4 },
      { expr: "‚àö64", valor: 8 },
      { expr: "‚àö81", valor: 9 },
      { expr: "2¬≤√ó2", valor: 8 },
      { expr: "3√ó3", valor: 9 }
    ];

    // Elementos DOM
    const tablero = document.getElementById('tablero');
    const mano = document.getElementById('mano');

    // Crear fichas de domin√≥ (con DOS VALORES DIFERENTES)
    function generarFichas() {
      const fichas = [];
      const expUsadas = new Set();
      
      // Crear 10 fichas con valores diferentes en cada lado
      for (let i = 0; i < 10; i++) {
        let exp1, exp2;
        
        // Buscar dos expresiones con valores DIFERENTES
        do {
          exp1 = expresiones[Math.floor(Math.random() * expresiones.length)];
          exp2 = expresiones[Math.floor(Math.random() * expresiones.length)];
        } while (exp1.valor === exp2.valor || expUsadas.has(exp1.expr + exp2.expr));
        
        expUsadas.add(exp1.expr + exp2.expr);
        
        fichas.push({
          id: i + 1,
          ladoA: { expr: exp1.expr, valor: exp1.valor },
          ladoB: { expr: exp2.expr, valor: exp2.valor },
          rotacion: 0
        });
      }
      
      return fichas;
    }

    // Crear elemento ficha
    function crearFicha(f) {
      // Crear contenedor
      const container = document.createElement("div");
      container.className = "ficha-container";
      container.dataset.id = f.id;
      
      // Crear ficha
      const div = document.createElement("div");
      div.className = "ficha";
      div.dataset.valorA = f.ladoA.valor;
      div.dataset.valorB = f.ladoB.valor;
      div.dataset.rotacion = f.rotacion || 0;

      div.innerHTML = `
        <div class="lado lado-a" data-valor="${f.ladoA.valor}">${f.ladoA.expr}</div>
        <div class="separador"></div>
        <div class="lado lado-b" data-valor="${f.ladoB.valor}">${f.ladoB.expr}</div>
      `;
      
      // Crear botones (fuera de la ficha, en el contenedor)
      const botones = document.createElement("div");
      botones.className = "botones";
      botones.innerHTML = `
        <button class="rotarL" onclick="event.stopPropagation(); rotarFicha(${f.id}, -90)">‚Ü∫ 90¬∞</button>
        <button class="rotarR" onclick="event.stopPropagation(); rotarFicha(${f.id}, 90)">‚Üª 90¬∞</button>
      `;
      
      container.appendChild(div);
      container.appendChild(botones);

      activarArrastre(container, div);
      return container;
    }

    // Activar arrastre
    function activarArrastre(container, fichaElem) {
      let offsetX, offsetY;
      let grupoArrastrado = [];

      container.addEventListener('mousedown', iniciarArrastre);

      function iniciarArrastre(e) {
        // Si se hace clic en los botones de rotaci√≥n, no arrastrar
        if (e.target.tagName === 'BUTTON') return;
        
        e.preventDefault();
        
        // Si la ficha est√° en la mano, moverla primero al tablero
        if (container.parentElement === mano) {
          // Colocar fichas en columna al bajarlas al tablero
          const fichasEnMano = mano.querySelectorAll('.ficha-container').length;
          const posicionX = 50 + (fichasEnMano * 160) % 600; // Distribuir en horizontal
          const posicionY = 50 + Math.floor((fichasEnMano * 160) / 600) * 100; // Nueva fila cada 4 fichas
          
          tablero.appendChild(container);
          container.style.position = 'absolute';
          container.style.left = posicionX + 'px';
          container.style.top = posicionY + 'px';
        }
        
        const rect = container.getBoundingClientRect();
        const tableroRect = tablero.getBoundingClientRect();
        
        // Calcular el offset exacto desde donde se hizo clic hasta la esquina superior izquierda
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        // Encontrar el grupo de fichas conectadas que se deben mover juntas
        grupoArrastrado = obtenerGrupoConectado(parseInt(container.dataset.id));
        
        // Poner todas las fichas del grupo en z-index alto
        grupoArrastrado.forEach(fichaData => {
          fichaData.container.style.zIndex = "1000";
          fichaData.container.style.cursor = "grabbing";
          // Guardar posici√≥n inicial relativa
          const fichaRect = fichaData.container.getBoundingClientRect();
          fichaData.offsetX = fichaRect.left - rect.left;
          fichaData.offsetY = fichaRect.top - rect.top;
        });

        document.addEventListener('mousemove', arrastrar);
        document.addEventListener('mouseup', soltarFicha);
      }

      function arrastrar(e) {
        e.preventDefault();
        
        const tableroRect = tablero.getBoundingClientRect();
        
        // Posicionar todas las fichas del grupo manteniendo sus posiciones relativas
        grupoArrastrado.forEach(fichaData => {
          let x = e.clientX - tableroRect.left - offsetX + fichaData.offsetX;
          let y = e.clientY - tableroRect.top - offsetY + fichaData.offsetY;

          fichaData.container.style.left = x + "px";
          fichaData.container.style.top = y + "px";
        });
      }

      function soltarFicha(e) {
        document.removeEventListener('mousemove', arrastrar);
        document.removeEventListener('mouseup', soltarFicha);
        
        grupoArrastrado.forEach(fichaData => {
          fichaData.container.style.zIndex = "10";
          fichaData.container.style.cursor = "move";
        });

        // A√±adir a tablero si no est√° ya
        const fichaId = parseInt(container.dataset.id);
        if (!estado.fichasEnTablero.find(f => f.id === fichaId)) {
          estado.fichasEnTablero.push({
            id: fichaId,
            container: container,
            elemento: fichaElem,
            valorA: parseInt(fichaElem.dataset.valorA),
            valorB: parseInt(fichaElem.dataset.valorB)
          });
        }

        // Aplicar enganche magn√©tico
        aplicarEngancheMagnetico(container, fichaElem);
        
        verificarConexiones();
      }
    }
    
    // Obtener todas las fichas conectadas en un grupo
    function obtenerGrupoConectado(fichaId) {
      const fichaInicial = estado.fichasEnTablero.find(f => f.id === fichaId);
      if (!fichaInicial) return [];
      
      const grupo = [fichaInicial];
      const visitados = new Set([fichaId]);
      const porVisitar = [fichaId];
      
      while (porVisitar.length > 0) {
        const actualId = porVisitar.shift();
        
        // Buscar fichas conectadas a esta
        estado.fichasEnTablero.forEach(otraFicha => {
          if (visitados.has(otraFicha.id)) return;
          
          // Verificar si est√°n conectadas
          if (estanConectadas(actualId, otraFicha.id)) {
            visitados.add(otraFicha.id);
            porVisitar.push(otraFicha.id);
            grupo.push(otraFicha);
          }
        });
      }
      
      return grupo;
    }
    
    // Verificar colisiones con otras fichas
    function verificarColisiones(containerMoviendo, x, y, grupoMoviendo) {
      const idsGrupo = new Set(grupoMoviendo.map(f => f.container.dataset.id));
      const margen = 5; // P√≠xeles de separaci√≥n m√≠nima
      
      // Dimensiones aproximadas de la ficha (considerando rotaci√≥n)
      const anchoFicha = 140;
      const altoFicha = 70;
      
      let xFinal = x;
      let yFinal = y;
      
      // Verificar colisi√≥n con cada otra ficha
      estado.fichasEnTablero.forEach(otraFicha => {
        // No verificar colisi√≥n con fichas del mismo grupo
        if (idsGrupo.has(otraFicha.container.dataset.id.toString())) return;
        
        const otroX = parseFloat(otraFicha.container.style.left) || 0;
        const otroY = parseFloat(otraFicha.container.style.top) || 0;
        
        // Calcular si hay solapamiento en eje X
        const solapamientoX = Math.abs(xFinal - otroX) < (anchoFicha + margen);
        // Calcular si hay solapamiento en eje Y
        const solapamientoY = Math.abs(yFinal - otroY) < (altoFicha + margen);
        
        if (solapamientoX && solapamientoY) {
          // Hay colisi√≥n, ajustar posici√≥n
          const dx = xFinal - otroX;
          const dy = yFinal - otroY;
          
          // Empujar en la direcci√≥n con mayor separaci√≥n
          if (Math.abs(dx) > Math.abs(dy)) {
            // Separar horizontalmente
            xFinal = otroX + (dx > 0 ? anchoFicha + margen : -(anchoFicha + margen));
          } else {
            // Separar verticalmente
            yFinal = otroY + (dy > 0 ? altoFicha + margen : -(altoFicha + margen));
          }
        }
      });
      
      return { x: xFinal, y: yFinal };
    }
    function estanConectadas(fichaId1, fichaId2) {
      const ficha1 = estado.fichasEnTablero.find(f => f.id === fichaId1);
      const ficha2 = estado.fichasEnTablero.find(f => f.id === fichaId2);
      
      if (!ficha1 || !ficha2) return false;
      
      const rect1 = ficha1.elemento.getBoundingClientRect();
      const rect2 = ficha2.elemento.getBoundingClientRect();
      
      const ladosA1 = getLadosCentros(rect1, parseInt(ficha1.elemento.dataset.rotacion) || 0);
      const ladosA2 = getLadosCentros(rect2, parseInt(ficha2.elemento.dataset.rotacion) || 0);
      
      // Verificar todas las combinaciones de lados
      const combinaciones = [
        { lado1: 'izq', valor1: ficha1.valorA, lado2: 'izq', valor2: ficha2.valorA },
        { lado1: 'izq', valor1: ficha1.valorA, lado2: 'der', valor2: ficha2.valorB },
        { lado1: 'der', valor1: ficha1.valorB, lado2: 'izq', valor2: ficha2.valorA },
        { lado1: 'der', valor1: ficha1.valorB, lado2: 'der', valor2: ficha2.valorB }
      ];
      
      for (const combo of combinaciones) {
        if (combo.valor1 === combo.valor2) {
          const p1 = ladosA1[combo.lado1];
          const p2 = ladosA2[combo.lado2];
          const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
          
          if (dist < config.distanciaConexion) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Aplicar enganche magn√©tico a fichas cercanas
    function aplicarEngancheMagnetico(fichaContainerArrastrado, fichaElemArrastrado) {
      const fichaId = parseInt(fichaContainerArrastrado.dataset.id);
      const fichaData = estado.fichasEnTablero.find(f => f.id === fichaId);
      if (!fichaData) return;
      
      const rect1 = fichaElemArrastrado.getBoundingClientRect();
      const rotacion1 = parseInt(fichaElemArrastrado.dataset.rotacion) || 0;
      const ladosA1 = getLadosCentros(rect1, rotacion1);
      const tableroRect = tablero.getBoundingClientRect();
      
      // Buscar la ficha m√°s cercana con valor compatible
      let mejorEnganche = null;
      let menorDistancia = config.distanciaEnganche;
      
      estado.fichasEnTablero.forEach(otraFicha => {
        if (otraFicha.id === fichaId) return;
        
        const rect2 = otraFicha.elemento.getBoundingClientRect();
        const rotacion2 = parseInt(otraFicha.elemento.dataset.rotacion) || 0;
        const ladosA2 = getLadosCentros(rect2, rotacion2);
        
        // Verificar todas las combinaciones de lados
        const combinaciones = [
          { lado1: 'izq', valor1: fichaData.valorA, lado2: 'der', valor2: otraFicha.valorB, p1: ladosA1.izq, p2: ladosA2.der },
          { lado1: 'der', valor1: fichaData.valorB, lado2: 'izq', valor2: otraFicha.valorA, p1: ladosA1.der, p2: ladosA2.izq }
        ];
        
        combinaciones.forEach(combo => {
          if (combo.valor1 === combo.valor2) {
            const dist = Math.sqrt(Math.pow(combo.p1.x - combo.p2.x, 2) + Math.pow(combo.p1.y - combo.p2.y, 2));
            
            if (dist < menorDistancia) {
              menorDistancia = dist;
              
              // Calcular la distancia exacta entre bordes para que no se superpongan
              let offsetEnganche = 140; // Ancho de la ficha
              
              // Si est√°n en perpendicular (una a 90¬∞ de la otra), ajustar
              const difRotacion = Math.abs(rotacion1 - rotacion2) % 180;
              if (difRotacion === 90) {
                offsetEnganche = 70; // Mitad del ancho cuando est√°n perpendiculares
              }
              
              // Calcular vector de direcci√≥n entre los dos puntos
              const dx = combo.p2.x - combo.p1.x;
              const dy = combo.p2.y - combo.p1.y;
              const distActual = Math.sqrt(dx * dx + dy * dy);
              
              if (distActual > 0) {
                // Normalizar y aplicar la distancia correcta
                const factorNorm = offsetEnganche / distActual;
                mejorEnganche = {
                  ajusteX: dx * factorNorm,
                  ajusteY: dy * factorNorm
                };
              }
            }
          }
        });
      });
      
      // Aplicar el enganche si se encontr√≥ uno
      if (mejorEnganche) {
        const left = parseFloat(fichaContainerArrastrado.style.left) || 0;
        const top = parseFloat(fichaContainerArrastrado.style.top) || 0;
        
        fichaContainerArrastrado.style.left = (left + mejorEnganche.ajusteX) + "px";
        fichaContainerArrastrado.style.top = (top + mejorEnganche.ajusteY) + "px";
      }
    }

    // Rotar ficha
    function rotarFicha(fichaId, grados) {
      const container = document.querySelector(`[data-id="${fichaId}"]`);
      if (!container) return;
      
      const ficha = container.querySelector('.ficha');
      if (!ficha) return;
      
      // Actualizar rotaci√≥n
      let rotActual = parseInt(ficha.dataset.rotacion) || 0;
      rotActual += grados;
      
      // Normalizar a -270, -180, -90, 0, 90, 180, 270
      while (rotActual > 180) rotActual -= 360;
      while (rotActual < -180) rotActual += 360;
      
      ficha.dataset.rotacion = rotActual;
      
      // Aplicar rotaci√≥n a la ficha
      ficha.style.transform = `rotate(${rotActual}deg)`;
      ficha.style.transformOrigin = 'center center';
      
      setTimeout(() => verificarConexiones(), 100);
    }

    // Verificar conexiones entre fichas
    function verificarConexiones() {
      // Limpiar conexiones visuales previas
      document.querySelectorAll('.conexion').forEach(c => c.remove());
      document.querySelectorAll('.lado.match').forEach(l => l.classList.remove('match'));
      
      let conexionesEncontradas = 0;

      estado.fichasEnTablero.forEach((ficha1, idx1) => {
        estado.fichasEnTablero.forEach((ficha2, idx2) => {
          if (idx1 >= idx2) return;

          const rect1 = ficha1.elemento.getBoundingClientRect();
          const rect2 = ficha2.elemento.getBoundingClientRect();
          const tableroRect = tablero.getBoundingClientRect();

          // Obtener centros de cada lado
          const ladosA1 = getLadosCentros(rect1, parseInt(ficha1.elemento.dataset.rotacion) || 0);
          const ladosA2 = getLadosCentros(rect2, parseInt(ficha2.elemento.dataset.rotacion) || 0);

          // Verificar si alg√∫n lado de ficha1 est√° cerca de alg√∫n lado de ficha2 CON EL MISMO VALOR
          [
            { lado1: 'izq', valor1: ficha1.valorA, lado2: 'izq', valor2: ficha2.valorA },
            { lado1: 'izq', valor1: ficha1.valorA, lado2: 'der', valor2: ficha2.valorB },
            { lado1: 'der', valor1: ficha1.valorB, lado2: 'izq', valor2: ficha2.valorA },
            { lado1: 'der', valor1: ficha1.valorB, lado2: 'der', valor2: ficha2.valorB }
          ].forEach(combo => {
            if (combo.valor1 === combo.valor2) {
              const p1 = ladosA1[combo.lado1];
              const p2 = ladosA2[combo.lado2];
              const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

              if (dist < config.distanciaConexion) {
                dibujarLinea(p1.x, p1.y, p2.x, p2.y, tableroRect);
                marcarLadosConectados(ficha1.elemento, combo.lado1, ficha2.elemento, combo.lado2);
                conexionesEncontradas++;
              }
            }
          });
        });
      });

      if (conexionesEncontradas !== estado.conexiones) {
        estado.conexiones = conexionesEncontradas;
        estado.puntuacion = conexionesEncontradas * config.puntosPorConexion;
        actualizarUI();

        if (conexionesEncontradas >= 9) {
          mostrarMensaje("üéâ ¬°Felicidades! Has conectado todas las fichas", true);
          clearInterval(estado.temporizador);
        }
      }
    }

    // Obtener centros de los lados de una ficha seg√∫n rotaci√≥n
    function getLadosCentros(rect, rotacion) {
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const w = 70; // Ancho de la ficha / 2

      rotacion = ((rotacion % 360) + 360) % 360;

      if (rotacion === 0) {
        return { izq: { x: cx - w, y: cy }, der: { x: cx + w, y: cy } };
      } else if (rotacion === 90 || rotacion === -270) {
        return { izq: { x: cx, y: cy + w }, der: { x: cx, y: cy - w } };
      } else if (rotacion === 180 || rotacion === -180) {
        return { izq: { x: cx + w, y: cy }, der: { x: cx - w, y: cy } };
      } else if (rotacion === 270 || rotacion === -90) {
        return { izq: { x: cx, y: cy - w }, der: { x: cx, y: cy + w } };
      }

      return { izq: { x: cx - w, y: cy }, der: { x: cx + w, y: cy } };
    }

    // Marcar lados como conectados
    function marcarLadosConectados(elem1, lado1, elem2, lado2) {
      const selector1 = lado1 === 'izq' ? '.lado-a' : '.lado-b';
      const selector2 = lado2 === 'izq' ? '.lado-a' : '.lado-b';
      
      elem1.querySelector(selector1).classList.add('match');
      elem2.querySelector(selector2).classList.add('match');
    }

    // Dibujar l√≠nea de conexi√≥n
    function dibujarLinea(x1, y1, x2, y2, tableroRect) {
      const linea = document.createElement('div');
      linea.className = 'conexion';

      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;

      linea.style.width = `${length}px`;
      linea.style.left = `${x1 - tableroRect.left}px`;
      linea.style.top = `${y1 - tableroRect.top}px`;
      linea.style.transform = `rotate(${angle}deg)`;

      tablero.appendChild(linea);
    }

    // Iniciar juego
    function iniciarJuego() {
      clearInterval(estado.temporizador);
      estado = {
        puntuacion: 0,
        conexiones: 0,
        tiempoRestante: config.tiempoTotal,
        temporizador: null,
        fichasEnTablero: [],
        lineasConexion: [],
        gruposConectados: []
      };

      tablero.innerHTML = '';
      mano.innerHTML = '<h3 style="margin-bottom: 10px;">Tu Mano</h3><p style="font-size: 0.9rem; color: #64748b;">Arrastra al tablero ‚Üí</p>';

      const fichas = generarFichas();
      fichas.forEach((f, i) => {
        const elem = crearFicha(f);
        elem.style.position = 'relative';
        elem.style.top = 'auto';
        elem.style.left = 'auto';
        elem.style.marginBottom = '50px';
        mano.appendChild(elem);
      });

      actualizarUI();
      estado.temporizador = setInterval(() => {
        estado.tiempoRestante--;
        document.getElementById('tiempo').textContent = estado.tiempoRestante;
        if (estado.tiempoRestante <= 0) {
          clearInterval(estado.temporizador);
          mostrarMensaje(`‚è∞ Tiempo agotado. Puntuaci√≥n final: ${estado.puntuacion}`);
        }
      }, 1000);
    }

    // Actualizar UI
    function actualizarUI() {
      document.getElementById('puntuacion').textContent = estado.puntuacion;
      document.getElementById('conexiones').textContent = estado.conexiones;
      document.getElementById('tiempo').textContent = estado.tiempoRestante;
    }

    // Mostrar mensaje
    function mostrarMensaje(texto, esVictoria = false) {
      const msg = document.getElementById('message');
      msg.textContent = texto;
      msg.style.display = 'block';
      msg.style.borderColor = esVictoria ? '#10b981' : '#0ea5e9';

      setTimeout(() => {
        msg.style.display = 'none';
      }, 3000);
    }

    // Voltear todas
    function voltearTodas() {
      document.querySelectorAll('.ficha').forEach(f => {
        let rot = (parseInt(f.dataset.rotacion) || 0) + 180;
        f.dataset.rotacion = rot;
        f.style.transform = `rotate(${rot}deg)`;
      });
      setTimeout(verificarConexiones, 200);
    }

    // Dar pista
    function darPista() {
      mostrarMensaje("üí° Busca fichas con lados que tengan el mismo valor num√©rico y ac√©rcalas");
    }

    // Event listeners
    document.getElementById('btn-nueva-partida').onclick = iniciarJuego;
    document.getElementById('btn-voltear-todas').onclick = voltearTodas;
    document.getElementById('btn-pista').onclick = darPista;

    // Iniciar al cargar
    window.onload = iniciarJuego;
  </script>
</body>
</html>
